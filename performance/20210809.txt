# 20210809白板

+ 内存
  + 内存地址  + 内存存储单元
  + 内存中数据结构
    + 列表：往列表中插入数据，插入点之后的数据，全部都需要移动，这个插入速度比较慢
    + 链表：每一个数据，它都存储了下一个数据的地址(内存地址)，在插入数据的时候，我可以把数据放在任何位置
      + 链表在查数据时，它的链路可能会很长，那么它的IO可能消耗比较高
    + 二叉树
      + 它也链表
      + 插入数据时，数据进行比较，比数据小的在左边，比数据大的插入在右边
      + 查找数据时，比数据大的，我就去右边找，比数据小，我就去左边找，这个时候，IO就比链表要少很多。
+ 数据类型：
  + 栈stack： 存储的数据比较小，比如某个变量
    + LIFO  后进先出
      + 压入 push
      + 弹出 pop  弹出我们最后一个数据
  + 队列： FIFO   排队
    + 顺序队列，
    + 循环队列
  + 堆heap： 存储的数据比较复杂
    + 对象



+ 一个程序： 如： 这个程序启动要 256m

  + 先有一个虚拟内存地址  +  物理内存地址
  + 虚拟内存地址： 记录物理内存中存储了哪些数据，在什么地方

+ jvm： java虚拟机

  + 程序计数器、java虚拟机栈、本地方法栈、方法区、堆内存
  + 程序计数器：记录程序执行字节码的行号指示器

  + **内存泄漏**： 内存的资源不及时释放，一直占用，导致可用的内存资源越来越少。
  + **内存溢出**：内存泄漏到一定的时间，可用的空间就会越来越少，某一次我要用比较大的空间时，发现，我申请不到足够的空间了，我申请的空间已经超过最大可用空间，内存溢出。
    + 内存溢出，在错误日志，会出现
    + jmap
    + arthas

top:  进程列表中有3列，  虚拟内存、物理内存、共享内存

+ 堆内存：新生代、老年代、永久代(元空间)
  + 新生代new：昙花一现，朝生夕死的对
    + 如：你写的代码，方法里面变量
  + 老年代Tenured：
    + 新生代数据，经过copy算法，如copy了15次，

​	

YGC:Young Generation   Minor GC

FGC:Major GC

资源回收的时候，都会出现卡顿，YGC的卡断时间会比较短，FGC卡顿的时间会比较长

性能测试中，就对于这个gc是要关注

+ 如果 新生代资源分配过多，那么，老年代这变就要少， 老年代的空间，我可能就要经常的进行FGC， FGC频率高了，那么累计的gc的时间就长，导致性能比较差

+ 如果 新生代分配的资源少了，那么老年代就分配多些，我的新生代的资源回收频率YGC就要高， 那么累计的ygc的时间也可能长，我的性能也可能较差



+ gc资源回收
  + 哪些是可以被回收？
    + 是否已死



-XX:SurivivorRatio=8   eden空间、from空间、to空间的比例 8:1:1

-XX:MaxMetaspaceSize   jdk1.7  jdk1.8这个元空间参数配置名称变了



+ 查看内存：
  + free -h