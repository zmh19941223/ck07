# 20210806白板

+ 实战
  + stress-ng  
    + 模拟了进程上下文切换
    + 模拟了线程上下文切换
    + IO密集型
      + IO不要再理解为：读写操作，换入换出

+ IO密集型，导致服务器平均负载比较高

  ```sh
  stress-ng  -i 6 --hdd 1 --timeout 150
  ```

  

  + top:
    + loadaverage  上升
    + cpu： wa值很大  us、sy不是很大， buff/cache有增大
  + vmstat  1: mem free减少， cache有明显的增大， **bo**有明显数据， 说明有大量磁盘数据交换
  + mpstat -P ALL 3  ： %iowat 数值比较大  再次证明，我们线程系统负载比较高的原因是，系统的磁盘读写测试性能瓶颈，  哪到底是哪个进程导致我们的磁盘读写高？
  + pidstat -w 1    stress-ng-hdd这个进程的 自愿上下文切换数据比较大，pid的值  进程id

===你们考虑一下，这个问题这么解决？

​	----已经定位到了具体是哪个程序导致了

​		要么换磁盘，要么迁移到io性能更好的服务器

​			如果你是整体的迁移你的数据库，这个风险比较大，我们可以再另外一个IO性能比较好服务器，再安装一个数据库，做要给数据库读写分离。

​		要么 减少io操作

要定位到具体代码：

思路：具体进程id之后， 找到进程线程id，然后把线程id进行16进制转换， 进程id日志打印出来，过滤出线程id(16进程)



+ 内存知识
  + 当打开一个软件，就会分配虚拟内存、物理内存空间，cpu读取虚拟内存
  + 程序在启动时，并不会把所有的数据，加到内存
  + 32位的系统，最大支持的内存条，只有4g，64位系统，最大可以支持128T
  + 程序在启动时，会有一个内存配置信息，就会告诉系统，我要在整改内存条中，申请多少m内存空间。

+ 内存中，内存地址与存储单元组成的
  + 存储单元中，就是来真正存储内容
  + 不同的数据类型，存储单元大小不一样
    + int float, char
    + 列表  数组
    + python：列表 [8,'nmb',['vip8','vip12'],]
      + 列表中，插入一个数据，要把插入位置之后的所有数据都移动位置
      + 所以，这种，速度是比较慢
+ 数据结构
  + 链表：  自行车链条
  + 每一个数据，都有自己的地址 + 数据 +下一个数据的地址
  + 插入数据时， 数据本身可以在内存空间的任意位置，然后，在插入数据的位置前一个数据改变下一个数据地址，指向我的这位置，我的数据位置记录的下一个位置......
  + 这种数据插入方式，速度要比列表要块
  + 但是，读取某个数据的速度降低，因为我们每查询一个数据，都要从链表的第1个数据开始查找，一直到找到为止，这个中间，我们可能要进行大量IO数据交互

+ 堆栈：  两种数据结构
  + 栈： LIFO
  + 队列：FIFO
  + 堆：



​	